import re
import json
import logging
import xml
from xml.etree import ElementTree as ET

logger = logging.getLogger(__name__)


def extractSingleFunction(output_text: str):
    """
    Extracts a single function call from the provided XML-formatted string.

    Args:
        output_text (str): The input string containing XML-formatted data.

    Returns:
        List[Dict] | None: A list of dictionaries representing the function calls found, or None if no match is found.

    Logs:
        - Logs the match for the single function pattern.
        - Logs the extracted single function group.
        - Logs all the function calls found within the XML.

    Note:
        If the XML parsing fails, it falls back to extracting using regular expressions.
    """
    try:
        pattern = r"(<singlefunction>(.*?)</singlefunction>)"
        match = re.search(pattern, output_text, re.DOTALL)
        logging.info(f"Single Function Match: {match}")
        if not match:
            return None
        fn = match.group(1)
        logging.info(f"Single Function Group: {fn}")
        root = ET.fromstring(fn)
        functions = root.findall("functioncall")
        logging.info(f"All Function Calls: {functions}")
        return [json.loads(fn.text) for fn in functions]
    except ET.ParseError:
        return extractUsingRegEx(output_text)


def extractUsingRegEx(output_text: str):
    """
    Extracts function calls using regular expressions from the provided string.

    Args:
        output_text (str): The input string containing XML-like formatted data.

    Returns:
        List[Dict]: A list of dictionaries representing the function calls found, or an empty list if no match is found.

    Logs:
        - Logs the matches found in the exception block.

    Note:
        The function attempts to decode JSON strings within <functioncall> tags. If a JSON string fails to decode, it is skipped.
    """
    pattern = r"<functioncall>\s*(\{.*?\})\s*</functioncall>"
    matches = re.findall(pattern, output_text, re.DOTALL)
    logging.info(f"Exception block Matches: {matches}")

    results = []
    for json_string in matches:
        try:
            json_data = json.loads(json_string)
            results.append(json_data)
        except json.JSONDecodeError as err:
            print(f"Error decoding JSON: {str(err)}")
            continue
    return results
