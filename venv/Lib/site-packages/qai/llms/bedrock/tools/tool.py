from pydantic import BaseModel
from typing import List, Dict, Union, Literal, Optional
from .prompts.llama_tools import *
from .extract.multiple import extractMultipleFunctions
from .extract.single import extractSingleFunction


class FunctionSchema(BaseModel):
    """
    Schema representing a function's metadata.

    Attributes:
        name (str): The name of the function.
        description (str): A brief description of the function.
        parameters (Dict): A dictionary containing the parameter details of the function.
    """
    name: str
    description: str
    parameters: Dict


class Functions(BaseModel):
    """
    A model representing a list of function schemas.

    Attributes:
        functions (List[FunctionSchema]): A list containing instances of FunctionSchema.
    """
    functions: List[FunctionSchema]


class ToolChoice(BaseModel):
    """
    A model representing the choice of a tool.

    Attributes:
        name (str): The name of the chosen tool.
    """
    name: str


class Message(BaseModel):
    """
    A model representing a single message in a conversation.

    Attributes:
        role (Literal["user", "assistant"]): The role of the message sender. Can be either "user" or "assistant".
        content (Union[str, List, List[Dict]]): The content of the message. Can be a string, a list, or a list of dictionaries.
    """
    role: Literal["user", "assistant"]
    content: Union[str, List, List[Dict]]


class Messages(BaseModel):
    """
    A model representing a list of messages in a conversation.

    Attributes:
        messages (List[Message]): A list containing instances of Message.
    """
    messages: List[Message]


class Tool:
    """
    A tool that facilitates function calls within a conversation context.
    """
    async def tool_call(self,
                        model: str,
                        messages: List[Dict],
                        complete,
                        tools: List[Dict],
                        tool_choice: Optional[Dict] = None,
                        multiple_tools: Optional[bool] = False,
                        attach_system: Optional[str] = None,
                        **kwargs):
        """
        Handles function calls by interacting with the conversation and models.

        Args:
            model (str): The name or identifier of the model to use.
            messages (List[Dict]): A list of message dictionaries containing the conversation.
            complete (Callable): A callable function to process the completion of the task.
            tools (List[Dict]): A list of tool definitions required for the function calls.
            tool_choice (Optional[Dict]): An optional dictionary specifying a specific tool choice.
            multiple_tools (Optional[bool]): A flag indicating if multiple tools will be used.
            attach_system (Optional[str]): An optional string to attach a system message to the conversation context.
            **kwargs: Additional keyword arguments passed to the complete function.

        Returns:
            List[Dict]: A list of dictionaries representing the function outputs.

        Raises:
            ValidationError: If the input messages or tools do not conform to the expected schema.
        """
        Messages.model_validate({"messages": messages})
        Functions.model_validate({"functions": tools})
        if multiple_tools:
            system = MULTI_FUNCTION_CALLS_OPEN_ENDED.format(functions=tools)
        else:
            if tool_choice:
                ToolChoice.model_validate(tool_choice)
                tool_name = tool_choice.get("name")
                system = SINGLE_FUNCTION_SPECIFIC_CALL.format(
                    functions=tools, function_name=tool_name)
            else:
                system = SINGLE_FUNCTION_OPEN_ENDED.format(functions=tools)
        if attach_system:
            system += f"\n\nTask: {attach_system}"
        messages = [{"role": "system", "content": system}] + messages
        output = await complete(model, messages, **kwargs)
        if multiple_tools:
            function_output = extractMultipleFunctions(output)

        else:
            function_output = extractSingleFunction(output)
        return function_output
